#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Calculatrice Scientifique Compl√®te avec Tkinter
================================================
Interface graphique responsive avec th√®mes clair/sombre,
historique scrollable et gestion d'erreurs robuste.

Fonctionnalit√©s :
- Op√©rations arithm√©tiques de base (+, -, *, /, %)
- Fonctions trigonom√©triques (sin, cos, tan) en degr√©s/radians
- Fonctions logarithmiques (log, ln)
- Puissances, racines, factorielles
- Parenth√®ses imbriqu√©es illimit√©es
- Constantes math√©matiques (œÄ, e)
- Historique des calculs avec timestamps
- Th√®mes personnalisables
- Raccourcis clavier
- Gestion des erreurs compl√®te
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import math
import re
from datetime import datetime
from typing import List, Dict, Tuple


class CalculatriceScientifique:
    """Calculatrice scientifique avec interface Tkinter avanc√©e."""
    
    # Configurations des th√®mes
    THEMES = {
        'clair': {
            'bg': '#f5f5f5',
            'fg': '#2c3e50',
            'display_bg': '#ffffff',
            'display_fg': '#2c3e50',
            'button_bg': '#ecf0f1',
            'button_fg': '#2c3e50',
            'button_active': '#bdc3c7',
            'operator_bg': '#3498db',
            'operator_fg': '#ffffff',
            'equal_bg': '#2ecc71',
            'equal_fg': '#ffffff',
            'clear_bg': '#e74c3c',
            'clear_fg': '#ffffff',
            'history_bg': '#ffffff',
            'history_fg': '#34495e'
        },
        'sombre': {
            'bg': '#1e272e',
            'fg': '#ecf0f1',
            'display_bg': '#2c3e50',
            'display_fg': '#ecf0f1',
            'button_bg': '#34495e',
            'button_fg': '#ecf0f1',
            'button_active': '#4a5f7f',
            'operator_bg': '#e67e22',
            'operator_fg': '#ffffff',
            'equal_bg': '#27ae60',
            'equal_fg': '#ffffff',
            'clear_bg': '#c0392b',
            'clear_fg': '#ffffff',
            'history_bg': '#2c3e50',
            'history_fg': '#bdc3c7'
        }
    }
    
    def __init__(self, root: tk.Tk):
        """
        Initialise la calculatrice.
        
        Args:
            root: Fen√™tre principale Tkinter
        """
        self.root = root
        self.root.title("üî¨ Calculatrice Scientifique")
        self.root.minsize(500, 600)
        self.root.geometry("600x700")
        
        # Variables d'√©tat
        self.expression = ""
        self.historique: List[Dict] = []
        self.mode_angle = "DEG"  # DEG ou RAD
        self.theme_actuel = "clair"
        self.derniere_reponse = 0
        
        # Configuration du style
        self.style = ttk.Style()
        self.configurer_styles()
        
        # Cr√©ation de l'interface
        self.creer_interface()
        
        # Raccourcis clavier
        self.configurer_raccourcis()
        
        # Centrer la fen√™tre
        self.centrer_fenetre()
    
    def configurer_styles(self):
        """Configure les styles ttk pour l'interface."""
        self.style.theme_use('clam')
        
        # Style pour les boutons
        self.style.configure('Calculator.TButton',
                            font=('Arial', 12, 'bold'),
                            borderwidth=1,
                            relief='raised')
        
        # Style pour les labels
        self.style.configure('Calculator.TLabel',
                            font=('Arial', 10))
    
    def creer_interface(self):
        """Cr√©e tous les composants de l'interface."""
        # Frame principal
        main_frame = tk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Barre de menu sup√©rieure
        self.creer_barre_menu(main_frame)
        
        # Zone d'affichage
        self.creer_affichage(main_frame)
        
        # Zone des boutons
        self.creer_boutons(main_frame)
        
        # Historique (collapsible)
        self.creer_historique(main_frame)
        
        # Appliquer le th√®me initial
        self.appliquer_theme()
    
    def creer_barre_menu(self, parent):
        """Cr√©e la barre de menu avec options."""
        menu_frame = tk.Frame(parent)
        menu_frame.pack(fill=tk.X, pady=(0, 5))
        
        # Bouton de changement de th√®me
        self.btn_theme = tk.Button(
            menu_frame,
            text="üåô Sombre",
            command=self.basculer_theme,
            font=('Arial', 9),
            relief=tk.FLAT,
            cursor='hand2'
        )
        self.btn_theme.pack(side=tk.LEFT, padx=5)
        
        # Bouton mode angle
        self.btn_angle = tk.Button(
            menu_frame,
            text=f"üìê {self.mode_angle}",
            command=self.basculer_mode_angle,
            font=('Arial', 9),
            relief=tk.FLAT,
            cursor='hand2'
        )
        self.btn_angle.pack(side=tk.LEFT, padx=5)
        
        # Bouton historique
        self.btn_historique = tk.Button(
            menu_frame,
            text="üìú Historique",
            command=self.basculer_historique,
            font=('Arial', 9),
            relief=tk.FLAT,
            cursor='hand2'
        )
        self.btn_historique.pack(side=tk.LEFT, padx=5)
        
        # Label info
        info_label = tk.Label(
            menu_frame,
            text="‚å®Ô∏è Enter=Calculer | Esc=Effacer | Backspace=Supprimer",
            font=('Arial', 8),
            fg='gray'
        )
        info_label.pack(side=tk.RIGHT, padx=5)
    
    def creer_affichage(self, parent):
        """Cr√©e la zone d'affichage de l'expression."""
        display_frame = tk.Frame(parent)
        display_frame.pack(fill=tk.X, pady=5)
        
        # Expression actuelle
        self.display = tk.Entry(
            display_frame,
            font=('Courier New', 20, 'bold'),
            justify=tk.RIGHT,
            relief=tk.SUNKEN,
            borderwidth=2
        )
        self.display.pack(fill=tk.X, ipady=15)
        self.display.insert(0, "0")
        
        # Sous-expression (r√©sultat partiel)
        self.sub_display = tk.Label(
            display_frame,
            text="",
            font=('Arial', 10),
            anchor=tk.E,
            fg='gray'
        )
        self.sub_display.pack(fill=tk.X, pady=(2, 0))
    
    def creer_boutons(self, parent):
        """Cr√©e la grille de boutons de la calculatrice."""
        buttons_frame = tk.Frame(parent)
        buttons_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Configuration de la grille responsive
        for i in range(6):
            buttons_frame.grid_rowconfigure(i, weight=1, uniform="row")
        for j in range(5):
            buttons_frame.grid_columnconfigure(j, weight=1, uniform="col")
        
        # D√©finition des boutons (texte, ligne, colonne, colspan, type)
        boutons = [
            # Ligne 0 - Fonctions scientifiques avanc√©es
            ('sin', 0, 0, 1, 'function'),
            ('cos', 0, 1, 1, 'function'),
            ('tan', 0, 2, 1, 'function'),
            ('log', 0, 3, 1, 'function'),
            ('ln', 0, 4, 1, 'function'),
            
            # Ligne 1 - Fonctions suppl√©mentaires
            ('‚àö', 1, 0, 1, 'function'),
            ('x¬≤', 1, 1, 1, 'function'),
            ('x ∏', 1, 2, 1, 'operator'),
            ('1/x', 1, 3, 1, 'function'),
            ('n!', 1, 4, 1, 'function'),
            
            # Ligne 2 - Parenth√®ses et constantes
            ('(', 2, 0, 1, 'number'),
            (')', 2, 1, 1, 'number'),
            ('œÄ', 2, 2, 1, 'number'),
            ('e', 2, 3, 1, 'number'),
            ('C', 2, 4, 1, 'clear'),
            
            # Ligne 3 - Nombres et op√©rations
            ('7', 3, 0, 1, 'number'),
            ('8', 3, 1, 1, 'number'),
            ('9', 3, 2, 1, 'number'),
            ('√∑', 3, 3, 1, 'operator'),
            ('‚å´', 3, 4, 1, 'clear'),
            
            # Ligne 4
            ('4', 4, 0, 1, 'number'),
            ('5', 4, 1, 1, 'number'),
            ('6', 4, 2, 1, 'number'),
            ('√ó', 4, 3, 1, 'operator'),
            ('%', 4, 4, 1, 'operator'),
            
            # Ligne 5
            ('1', 5, 0, 1, 'number'),
            ('2', 5, 1, 1, 'number'),
            ('3', 5, 2, 1, 'number'),
            ('-', 5, 3, 1, 'operator'),
            ('Ans', 5, 4, 1, 'number'),
            
            # Ligne 6
            ('0', 6, 0, 1, 'number'),
            ('.', 6, 1, 1, 'number'),
            ('=', 6, 2, 2, 'equal'),
            ('+', 6, 4, 1, 'operator'),
        ]
        
        self.boutons = {}
        for texte, row, col, colspan, btn_type in boutons:
            btn = tk.Button(
                buttons_frame,
                text=texte,
                font=('Arial', 14, 'bold'),
                cursor='hand2',
                relief=tk.RAISED,
                borderwidth=2
            )
            btn.grid(row=row, column=col, columnspan=colspan, 
                    sticky='nsew', padx=2, pady=2)
            
            # Lier l'√©v√©nement de clic
            if texte == '=':
                btn.config(command=self.calculer)
            elif texte == 'C':
                btn.config(command=self.effacer)
            elif texte == '‚å´':
                btn.config(command=self.supprimer)
            elif btn_type == 'function':
                btn.config(command=lambda t=texte: self.ajouter_fonction(t))
            else:
                btn.config(command=lambda t=texte: self.ajouter_caractere(t))
            
            self.boutons[texte] = btn
    
    def creer_historique(self, parent):
        """Cr√©e la zone d'historique scrollable."""
        self.history_frame = tk.Frame(parent)
        # Initialement cach√©
        
        # Titre
        title_frame = tk.Frame(self.history_frame)
        title_frame.pack(fill=tk.X, pady=(5, 0))
        
        tk.Label(
            title_frame,
            text="üìä Historique des calculs",
            font=('Arial', 11, 'bold')
        ).pack(side=tk.LEFT, padx=5)
        
        tk.Button(
            title_frame,
            text="üóëÔ∏è Effacer",
            command=self.effacer_historique,
            font=('Arial', 8),
            relief=tk.FLAT,
            cursor='hand2'
        ).pack(side=tk.RIGHT, padx=5)
        
        # Zone de texte scrollable
        self.history_text = scrolledtext.ScrolledText(
            self.history_frame,
            height=8,
            font=('Courier New', 10),
            wrap=tk.WORD,
            relief=tk.SUNKEN,
            borderwidth=2
        )
        self.history_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.history_text.config(state=tk.DISABLED)
    
    def configurer_raccourcis(self):
        """Configure les raccourcis clavier."""
        # Chiffres et op√©rateurs
        for char in '0123456789+-*/.()':
            self.root.bind(char, lambda e, c=e.char: self.ajouter_caractere(c))
        
        # Touches sp√©ciales
        self.root.bind('<Return>', lambda e: self.calculer())
        self.root.bind('<KP_Enter>', lambda e: self.calculer())
        self.root.bind('<Escape>', lambda e: self.effacer())
        self.root.bind('<BackSpace>', lambda e: self.supprimer())
        self.root.bind('<Delete>', lambda e: self.supprimer())
    
    def ajouter_caractere(self, char: str):
        """Ajoute un caract√®re √† l'expression."""
        # Convertir les caract√®res sp√©ciaux
        conversions = {
            '√ó': '*',
            '√∑': '/',
            'œÄ': str(math.pi),
            'e': str(math.e),
            'Ans': str(self.derniere_reponse)
        }
        
        if char in conversions:
            char = conversions[char]
        
        # Supprimer le "0" initial
        if self.expression == "" or self.expression == "0":
            if char not in ['+', '-', '*', '/', '%']:
                self.expression = char
            else:
                self.expression = "0" + char
        else:
            self.expression += char
        
        self.mettre_a_jour_affichage()
    
    def ajouter_fonction(self, fonction: str):
        """Ajoute une fonction math√©matique √† l'expression."""
        # Mapping des fonctions
        fonctions_map = {
            'sin': 'sin(',
            'cos': 'cos(',
            'tan': 'tan(',
            'log': 'log10(',
            'ln': 'log(',
            '‚àö': 'sqrt(',
            'x¬≤': '**2',
            'x ∏': '**',
            '1/x': '**(‚àí1)',
            'n!': '!'
        }
        
        if fonction in fonctions_map:
            func_str = fonctions_map[fonction]
            
            # Cas sp√©ciaux
            if fonction == 'x¬≤':
                if self.expression and self.expression[-1].isdigit():
                    self.expression += func_str
                else:
                    self.expression += '(' + func_str
            elif fonction == '1/x':
                if self.expression:
                    self.expression = f"({self.expression}){func_str}"
                else:
                    self.expression = "1/"
            elif fonction == 'n!':
                self.expression += func_str
            else:
                self.expression += func_str
        
        self.mettre_a_jour_affichage()
    
    def supprimer(self):
        """Supprime le dernier caract√®re."""
        if self.expression:
            self.expression = self.expression[:-1]
            if not self.expression:
                self.expression = "0"
            self.mettre_a_jour_affichage()
    
    def effacer(self):
        """Efface toute l'expression."""
        self.expression = "0"
        self.mettre_a_jour_affichage()
        self.sub_display.config(text="")
    
    def mettre_a_jour_affichage(self):
        """Met √† jour l'affichage de l'expression."""
        self.display.delete(0, tk.END)
        self.display.insert(0, self.expression)
    
    def calculer(self):
        """Calcule le r√©sultat de l'expression."""
        if not self.expression or self.expression == "0":
            return
        
        try:
            # Pr√©traitement de l'expression
            expr = self.pretraiter_expression(self.expression)
            
            # √âvaluation s√©curis√©e
            resultat = self.evaluer_expression(expr)
            
            # Formater le r√©sultat
            if isinstance(resultat, (int, float)):
                if resultat == int(resultat):
                    resultat_str = str(int(resultat))
                else:
                    resultat_str = f"{resultat:.10g}"
            else:
                resultat_str = str(resultat)
            
            # Ajouter √† l'historique
            self.ajouter_a_historique(self.expression, resultat_str)
            
            # Mettre √† jour l'affichage
            self.expression = resultat_str
            self.derniere_reponse = float(resultat_str) if resultat_str.replace('.', '').replace('-', '').isdigit() else 0
            self.mettre_a_jour_affichage()
            self.sub_display.config(text="")
            
        except ZeroDivisionError:
            self.afficher_erreur("‚ùå Erreur : Division par z√©ro")
        except ValueError as e:
            self.afficher_erreur(f"‚ùå Erreur de valeur : {str(e)}")
        except SyntaxError:
            self.afficher_erreur("‚ùå Erreur : Expression invalide")
        except Exception as e:
            self.afficher_erreur(f"‚ùå Erreur : {str(e)}")
    
    def pretraiter_expression(self, expr: str) -> str:
        """
        Pr√©traite l'expression pour la rendre √©valuable.
        
        Args:
            expr: Expression √† pr√©traiter
            
        Returns:
            Expression pr√©trait√©e
        """
        # Remplacer les symboles
        expr = expr.replace('√ó', '*').replace('√∑', '/')
        expr = expr.replace('œÄ', str(math.pi))
        expr = expr.replace('e', str(math.e))
        
        # G√©rer les fonctions trigonom√©triques
        for func in ['sin', 'cos', 'tan']:
            pattern = f'{func}\\(([^)]+)\\)'
            while re.search(pattern, expr):
                match = re.search(pattern, expr)
                if match:
                    angle_expr = match.group(1)
                    angle_value = self.evaluer_expression(angle_expr)
                    
                    # Convertir en radians si n√©cessaire
                    if self.mode_angle == 'DEG':
                        angle_value = math.radians(float(angle_value))
                    
                    # Calculer la fonction trigonom√©trique
                    if func == 'sin':
                        result = math.sin(float(angle_value))
                    elif func == 'cos':
                        result = math.cos(float(angle_value))
                    else:  # tan
                        result = math.tan(float(angle_value))
                    
                    expr = expr[:match.start()] + str(result) + expr[match.end():]
        
        # G√©rer les logarithmes
        expr = re.sub(r'log10\(([^)]+)\)', 
                     lambda m: str(math.log10(float(self.evaluer_expression(m.group(1))))), 
                     expr)
        expr = re.sub(r'log\(([^)]+)\)', 
                     lambda m: str(math.log(float(self.evaluer_expression(m.group(1))))), 
                     expr)
        
        # G√©rer les racines carr√©es
        expr = re.sub(r'sqrt\(([^)]+)\)', 
                     lambda m: str(math.sqrt(float(self.evaluer_expression(m.group(1))))), 
                     expr)
        
        # G√©rer les factorielles
        def calculer_factorielle(match):
            n = int(float(self.evaluer_expression(match.group(1))))
            if n < 0:
                raise ValueError("Factorielle d'un nombre n√©gatif impossible")
            if n > 170:
                raise ValueError("Factorielle trop grande (max 170)")
            return str(math.factorial(n))
        
        expr = re.sub(r'([0-9.]+)!', calculer_factorielle, expr)
        
        return expr
    
    def evaluer_expression(self, expr: str) -> float:
        """
        √âvalue une expression math√©matique de mani√®re s√©curis√©e.
        
        Args:
            expr: Expression √† √©valuer
            
        Returns:
            R√©sultat de l'√©valuation
        """
        # Environnement s√©curis√© pour eval
        safe_dict = {
            '__builtins__': {},
            'abs': abs,
            'round': round,
            'min': min,
            'max': max,
            'pow': pow
        }
        
        try:
            result = eval(expr, safe_dict)
            return result
        except:
            raise SyntaxError("Expression invalide")
    
    def afficher_erreur(self, message: str):
        """Affiche un message d'erreur."""
        self.sub_display.config(text=message, fg='red')
        self.root.after(3000, lambda: self.sub_display.config(text="", fg='gray'))
    
    def ajouter_a_historique(self, expression: str, resultat: str):
        """Ajoute un calcul √† l'historique."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        entree = {
            'time': timestamp,
            'expression': expression,
            'resultat': resultat
        }
        self.historique.append(entree)
        
        # Mettre √† jour l'affichage de l'historique
        self.history_text.config(state=tk.NORMAL)
        self.history_text.insert(tk.END, 
            f"[{timestamp}] {expression} = {resultat}\n")
        self.history_text.see(tk.END)
        self.history_text.config(state=tk.DISABLED)
    
    def effacer_historique(self):
        """Efface l'historique des calculs."""
        if messagebox.askyesno("Confirmation", 
                              "Voulez-vous vraiment effacer tout l'historique ?"):
            self.historique.clear()
            self.history_text.config(state=tk.NORMAL)
            self.history_text.delete(1.0, tk.END)
            self.history_text.config(state=tk.DISABLED)
    
    def basculer_historique(self):
        """Affiche/masque l'historique."""
        if self.history_frame.winfo_ismapped():
            self.history_frame.pack_forget()
            self.btn_historique.config(text="üìú Historique ‚ñº")
        else:
            self.history_frame.pack(fill=tk.BOTH, expand=True, pady=5)
            self.btn_historique.config(text="üìú Historique ‚ñ≤")
    
    def basculer_theme(self):
        """Bascule entre les th√®mes clair et sombre."""
        if self.theme_actuel == "clair":
            self.theme_actuel = "sombre"
            self.btn_theme.config(text="‚òÄÔ∏è Clair")
        else:
            self.theme_actuel = "clair"
            self.btn_theme.config(text="üåô Sombre")
        
        self.appliquer_theme()
    
    def basculer_mode_angle(self):
        """Bascule entre les modes degr√© et radian."""
        if self.mode_angle == "DEG":
            self.mode_angle = "RAD"
        else:
            self.mode_angle = "DEG"
        
        self.btn_angle.config(text=f"üìê {self.mode_angle}")
    
    def appliquer_theme(self):
        """Applique le th√®me s√©lectionn√© √† tous les composants."""
        theme = self.THEMES[self.theme_actuel]
        
        # Fen√™tre principale
        self.root.config(bg=theme['bg'])
        
        # Affichage
        self.display.config(
            bg=theme['display_bg'],
            fg=theme['display_fg'],
            insertbackground=theme['display_fg']
        )
        
        # Sous-affichage
        self.sub_display.config(
            bg=theme['bg'],
            fg='gray'
        )
        
        # Boutons de menu
        for btn in [self.btn_theme, self.btn_angle, self.btn_historique]:
            btn.config(
                bg=theme['button_bg'],
                fg=theme['button_fg'],
                activebackground=theme['button_active']
            )
        
        # Boutons de la calculatrice
        for texte, btn in self.boutons.items():
            if texte == '=':
                btn.config(
                    bg=theme['equal_bg'],
                    fg=theme['equal_fg'],
                    activebackground=theme['equal_bg']
                )
            elif texte in ['C', '‚å´']:
                btn.config(
                    bg=theme['clear_bg'],
                    fg=theme['clear_fg'],
                    activebackground=theme['clear_bg']
                )
            elif texte in ['+', '-', '√ó', '√∑', '%', 'x ∏']:
                btn.config(
                    bg=theme['operator_bg'],
                    fg=theme['operator_fg'],
                    activebackground=theme['operator_bg']
                )
            else:
                btn.config(
                    bg=theme['button_bg'],
                    fg=theme['button_fg'],
                    activebackground=theme['button_active']
                )
        
        # Historique
        if hasattr(self, 'history_text'):
            self.history_text.config(
                bg=theme['history_bg'],
                fg=theme['history_fg']
            )
    
    def centrer_fenetre(self):
        """Centre la fen√™tre sur l'√©cran."""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f'{width}x{height}+{x}+{y}')


def main():
    """Point d'entr√©e principal de l'application."""
    root = tk.Tk()
    app = CalculatriceScientifique(root)
    root.mainloop()


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Guide d'utilisation interactif de la Calculatrice Scientifique
=============================================================
D√©monstrations et exemples pratiques d'utilisation.
"""

import sys
from datetime import datetime


class GuideInteractif:
    """Guide d'utilisation avec exemples et d√©monstrations."""
    
    def __init__(self):
        """Initialise le guide."""
        self.exemples = self.preparer_exemples()
    
    def preparer_exemples(self):
        """Pr√©pare la liste des exemples cat√©goris√©s."""
        return {
            "Op√©rations de base": [
                ("Addition simple", "2 + 3", "5"),
                ("Soustraction", "10 - 4", "6"),
                ("Multiplication", "6 √ó 7", "42"),
                ("Division", "20 √∑ 4", "5"),
                ("Division d√©cimale", "10 √∑ 3", "3.333..."),
                ("Modulo", "17 % 5", "2"),
                ("Priorit√© op√©rateurs", "2 + 3 √ó 4", "14"),
                ("Avec parenth√®ses", "(2 + 3) √ó 4", "20"),
            ],
            
            "Parenth√®ses imbriqu√©es": [
                ("Simples", "(5 + 3) √ó 2", "16"),
                ("Doubles", "((2 + 3) √ó 4) - 1", "19"),
                ("Triples", "(((10 - 2) √ó 3) + 4) √∑ 2", "14"),
                ("Complexes", "((5 + 3) √ó (10 - 4)) √∑ 2", "24"),
                ("Multiples", "(10 √∑ 2) + (8 √ó 3) - (5 - 1)", "26"),
            ],
            
            "Fonctions trigonom√©triques (DEG)": [
                ("sin(30¬∞)", "sin(30)", "0.5"),
                ("cos(60¬∞)", "cos(60)", "0.5"),
                ("tan(45¬∞)", "tan(45)", "1"),
                ("sin(90¬∞)", "sin(90)", "1"),
                ("cos(180¬∞)", "cos(180)", "-1"),
                ("tan(0¬∞)", "tan(0)", "0"),
            ],
            
            "Fonctions trigonom√©triques (RAD)": [
                ("sin(œÄ/6)", "sin(œÄ√∑6)", "0.5"),
                ("cos(œÄ/3)", "cos(œÄ√∑3)", "0.5"),
                ("tan(œÄ/4)", "tan(œÄ√∑4)", "1"),
                ("sin(œÄ/2)", "sin(œÄ√∑2)", "1"),
                ("cos(œÄ)", "cos(œÄ)", "-1"),
            ],
            
            "Logarithmes": [
                ("log‚ÇÅ‚ÇÄ(100)", "log(100)", "2"),
                ("log‚ÇÅ‚ÇÄ(1000)", "log(1000)", "3"),
                ("log‚ÇÅ‚ÇÄ(1)", "log(1)", "0"),
                ("ln(e)", "ln(e)", "1"),
                ("ln(e¬≤)", "ln(e¬≤)", "2"),
                ("ln(1)", "ln(1)", "0"),
            ],
            
            "Puissances et racines": [
                ("5 au carr√©", "5¬≤", "25"),
                ("2 puissance 8", "2^8", "256"),
                ("10 puissance 3", "10¬≥", "1000"),
                ("Racine de 16", "‚àö16", "4"),
                ("Racine de 144", "‚àö144", "12"),
                ("Racine de 2", "‚àö2", "1.414..."),
            ],
            
            "Autres fonctions": [
                ("Inverse de 4", "1/4", "0.25"),
                ("Inverse de 8", "1√∑8", "0.125"),
                ("Factorielle 5", "5!", "120"),
                ("Factorielle 6", "6!", "720"),
                ("Factorielle 0", "0!", "1"),
            ],
            
            "Constantes": [
                ("Pi", "œÄ", "3.14159..."),
                ("Euler", "e", "2.71828..."),
                ("2œÄ", "2√óœÄ", "6.28318..."),
                ("œÄ¬≤", "œÄ¬≤", "9.86960..."),
                ("e¬≤", "e¬≤", "7.38905..."),
            ],
            
            "Expressions complexes": [
                ("G√©om√©trie 1", "œÄ √ó 5¬≤", "78.54 (aire cercle r=5)"),
                ("G√©om√©trie 2", "2 √ó œÄ √ó 5", "31.42 (p√©rim√®tre r=5)"),
                ("Trigonom√©trie", "10 √ó sin(30)", "5 (hauteur triangle)"),
                ("Finance", "1000 √ó (1.05)¬π‚Å∞", "1628.89 (int√©r√™ts)"),
                ("Statistique", "‚àö((100-85)¬≤)", "15 (√©cart)"),
                ("Physique", "(1√∑2) √ó 10 √ó 5¬≤", "125 (√©nergie)"),
            ],
            
            "Gestion d'erreurs": [
                ("Division par z√©ro", "10 √∑ 0", "‚ùå Erreur"),
                ("Racine n√©gative", "‚àö(-4)", "‚ùå Erreur"),
                ("Logarithme n√©gatif", "ln(-1)", "‚ùå Erreur"),
                ("Expression vide", "", "‚ùå Erreur"),
                ("Parenth√®se non ferm√©e", "(2 + 3", "‚ùå Erreur"),
                ("Op√©rateur invalide", "2 ++ 3", "‚ùå Erreur"),
            ],
        }
    
    def afficher_entete(self):
        """Affiche l'en-t√™te du guide."""
        print()
        print("‚ïî" + "‚ïê" * 78 + "‚ïó")
        print("‚ïë" + " " * 20 + "üìñ GUIDE D'UTILISATION INTERACTIF" + " " * 25 + "‚ïë")
        print("‚ïë" + " " * 20 + "Calculatrice Scientifique Tkinter" + " " * 25 + "‚ïë")
        print("‚ïö" + "‚ïê" * 78 + "‚ïù")
        print()
        print(f"üìÖ Date : {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        print(f"üêç Python : {sys.version.split()[0]}")
        print()
    
    def afficher_section(self, titre: str, exemples: list):
        """Affiche une section d'exemples."""
        print("=" * 80)
        print(f" {titre}")
        print("=" * 80)
        print()
        
        # Largeurs des colonnes
        col1_width = max(len(ex[0]) for ex in exemples) + 2
        col2_width = max(len(ex[1]) for ex in exemples) + 2
        
        # En-t√™te du tableau
        print(f"{'Description':<{col1_width}} ‚îÇ {'Expression':<{col2_width}} ‚îÇ R√©sultat attendu")
        print("‚îÄ" * col1_width + "‚îº" + "‚îÄ" * col2_width + "‚îº" + "‚îÄ" * 30)
        
        # Lignes du tableau
        for description, expression, resultat in exemples:
            print(f"{description:<{col1_width}} ‚îÇ {expression:<{col2_width}} ‚îÇ {resultat}")
        
        print()
    
    def afficher_raccourcis(self):
        """Affiche la liste des raccourcis clavier."""
        print("=" * 80)
        print(" ‚å®Ô∏è RACCOURCIS CLAVIER")
        print("=" * 80)
        print()
        
        raccourcis = [
            ("0-9, +, -, √ó, √∑, ., (, )", "Saisie directe des caract√®res"),
            ("Enter / ‚èé", "Calculer le r√©sultat de l'expression"),
            ("Escape / Esc", "Effacer toute l'expression"),
            ("Backspace / ‚å´", "Supprimer le dernier caract√®re"),
            ("Delete / Del", "Supprimer le dernier caract√®re"),
        ]
        
        for touche, action in raccourcis:
            print(f"  {touche:<30} ‚Üí {action}")
        
        print()
    
    def afficher_fonctionnalites(self):
        """Affiche les fonctionnalit√©s principales."""
        print("=" * 80)
        print(" ‚ú® FONCTIONNALIT√âS PRINCIPALES")
        print("=" * 80)
        print()
        
        fonctionnalites = [
            ("üßÆ Op√©rations de base", "Addition, soustraction, multiplication, division, modulo"),
            ("üìê Trigonom√©trie", "sin, cos, tan avec modes degr√©s (DEG) et radians (RAD)"),
            ("üìà Logarithmes", "log‚ÇÅ‚ÇÄ et ln (logarithme naturel)"),
            ("üî¢ Puissances", "Carr√© (x¬≤), puissance (x ∏), racine (‚àö)"),
            ("üî¨ Fonctions avanc√©es", "Inverse (1/x), factorielle (n!)"),
            ("üéØ Constantes", "œÄ (pi), e (Euler), Ans (dernier r√©sultat)"),
            ("üé® Th√®mes", "Clair et sombre, personnalisables"),
            ("üìú Historique", "Sauvegarde de tous les calculs avec horodatage"),
            ("üõ°Ô∏è Gestion d'erreurs", "Messages explicites pour toutes les erreurs"),
            ("üîÑ Responsive", "Interface adaptative et fluide"),
        ]
        
        for titre, description in fonctionnalites:
            print(f"  {titre:<25} ‚Üí {description}")
        
        print()
    
    def afficher_conseils(self):
        """Affiche des conseils d'utilisation."""
        print("=" * 80)
        print(" üí° CONSEILS ET ASTUCES")
        print("=" * 80)
        print()
        
        conseils = [
            "1. Utilisez les parenth√®ses pour contr√¥ler l'ordre des op√©rations",
            "2. Le mode angle (DEG/RAD) affecte toutes les fonctions trigonom√©triques",
            "3. 'Ans' permet de r√©utiliser le dernier r√©sultat dans un nouveau calcul",
            "4. L'historique est scrollable - utilisez la molette pour naviguer",
            "5. Les erreurs s'affichent pendant 3 secondes puis disparaissent",
            "6. Le th√®me sombre r√©duit la fatigue oculaire lors d'une utilisation prolong√©e",
            "7. Utilisez les raccourcis clavier pour une saisie plus rapide",
            "8. Les parenth√®ses peuvent √™tre imbriqu√©es sans limitation",
            "9. Le sous-affichage montre les r√©sultats interm√©diaires",
            "10. Double-cliquez sur l'historique pour r√©utiliser une expression",
        ]
        
        for conseil in conseils:
            print(f"  {conseil}")
        
        print()
    
    def afficher_exemples_pratiques(self):
        """Affiche des exemples pratiques d'utilisation."""
        print("=" * 80)
        print(" üéØ EXEMPLES PRATIQUES")
        print("=" * 80)
        print()
        
        exemples = [
            ("Calcul d'aire", "Aire d'un cercle de rayon 7", "œÄ √ó 7¬≤ = 153.94"),
            ("Calcul de volume", "Volume d'une sph√®re de rayon 5", "(4√∑3) √ó œÄ √ó 5¬≥ = 523.60"),
            ("Trigonom√©trie", "Hauteur d'un arbre (angle=35¬∞, distance=20m)", "20 √ó tan(35) = 14.00"),
            ("Finance", "Valeur future (1500‚Ç¨, 3% sur 5 ans)", "1500 √ó (1.03)‚Åµ = 1738.91"),
            ("Statistique", "√âcart-type de [10,20,30]", "‚àö(((10-20)¬≤+(20-20)¬≤+(30-20)¬≤)√∑3) = 8.16"),
            ("Physique", "√ânergie cin√©tique (m=50kg, v=10m/s)", "(1√∑2) √ó 50 √ó 10¬≤ = 2500 J"),
        ]
        
        for domaine, description, calcul in exemples:
            print(f"  üìå {domaine}")
            print(f"     {description}")
            print(f"     ‚Üí {calcul}")
            print()
    
    def generer_guide_complet(self):
        """G√©n√®re le guide complet."""
        self.afficher_entete()
        
        # Afficher toutes les sections d'exemples
        for titre, exemples in self.exemples.items():
            self.afficher_section(titre, exemples)
        
        # Afficher les autres sections
        self.afficher_fonctionnalites()
        self.afficher_raccourcis()
        self.afficher_exemples_pratiques()
        self.afficher_conseils()
        
        # Pied de page
        print("=" * 80)
        print(" üöÄ LANCEMENT DE L'APPLICATION")
        print("=" * 80)
        print()
        print("  Pour lancer la calculatrice :")
        print()
        print("    $ cd /home/user/calculatrice_scientifique")
        print("    $ python3 calculatrice.py")
        print()
        print("  Pour ex√©cuter les tests :")
        print()
        print("    $ python3 tests.py")
        print()
        print("=" * 80)
        print()


def main():
    """Point d'entr√©e principal."""
    guide = GuideInteractif()
    guide.generer_guide_complet()


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tests unitaires pour la Calculatrice Scientifique
=================================================
Suite de tests compl√®te pour valider toutes les fonctionnalit√©s.
"""

import math
import sys
from datetime import datetime


class TestCalculatrice:
    """Classe de tests pour la calculatrice."""
    
    def __init__(self):
        """Initialise le syst√®me de tests."""
        self.tests_reussis = 0
        self.tests_echoues = 0
        self.resultats = []
    
    def tester_operation(self, nom: str, expression: str, attendu: float, 
                        tolerance: float = 1e-10):
        """
        Teste une op√©ration math√©matique.
        
        Args:
            nom: Nom du test
            expression: Expression √† √©valuer
            attendu: R√©sultat attendu
            tolerance: Tol√©rance pour la comparaison des flottants
        """
        try:
            resultat = eval(expression)
            
            # Comparaison avec tol√©rance pour les flottants
            if isinstance(attendu, float):
                succes = abs(resultat - attendu) < tolerance
            else:
                succes = resultat == attendu
            
            if succes:
                self.tests_reussis += 1
                statut = "‚úÖ R√âUSSI"
                self.resultats.append((nom, True, None))
            else:
                self.tests_echoues += 1
                statut = "‚ùå √âCHOU√â"
                erreur = f"Attendu: {attendu}, Obtenu: {resultat}"
                self.resultats.append((nom, False, erreur))
            
            print(f"{statut} - {nom}")
            if not succes:
                print(f"   Expression: {expression}")
                print(f"   Attendu: {attendu}, Obtenu: {resultat}")
                
        except Exception as e:
            self.tests_echoues += 1
            print(f"‚ùå ERREUR - {nom}")
            print(f"   Expression: {expression}")
            print(f"   Exception: {str(e)}")
            self.resultats.append((nom, False, str(e)))
    
    def tester_erreur(self, nom: str, expression: str, type_erreur: type):
        """
        Teste qu'une expression g√©n√®re bien une erreur.
        
        Args:
            nom: Nom du test
            expression: Expression √† √©valuer
            type_erreur: Type d'erreur attendu
        """
        try:
            eval(expression)
            self.tests_echoues += 1
            print(f"‚ùå √âCHOU√â - {nom}")
            print(f"   L'erreur {type_erreur.__name__} n'a pas √©t√© lev√©e")
            self.resultats.append((nom, False, 
                                 f"Erreur {type_erreur.__name__} non lev√©e"))
        except type_erreur:
            self.tests_reussis += 1
            print(f"‚úÖ R√âUSSI - {nom}")
            self.resultats.append((nom, True, None))
        except Exception as e:
            self.tests_echoues += 1
            print(f"‚ùå √âCHOU√â - {nom}")
            print(f"   Mauvais type d'erreur: {type(e).__name__}")
            self.resultats.append((nom, False, 
                                 f"Mauvais type: {type(e).__name__}"))
    
    def executer_suite_tests(self):
        """Ex√©cute la suite compl√®te de tests."""
        print("=" * 70)
        print(" üß™ TESTS UNITAIRES - CALCULATRICE SCIENTIFIQUE")
        print("=" * 70)
        print()
        
        # Tests des op√©rations de base
        print("üìä Tests des op√©rations de base")
        print("-" * 70)
        self.tester_operation("Addition simple", "2 + 3", 5)
        self.tester_operation("Soustraction", "10 - 4", 6)
        self.tester_operation("Multiplication", "6 * 7", 42)
        self.tester_operation("Division", "15 / 3", 5.0)
        self.tester_operation("Division d√©cimale", "10 / 4", 2.5)
        self.tester_operation("Modulo", "17 % 5", 2)
        self.tester_operation("Puissance", "2 ** 3", 8)
        self.tester_operation("Op√©rations mixtes", "2 + 3 * 4", 14)
        self.tester_operation("Priorit√© des op√©rations", "(2 + 3) * 4", 20)
        print()
        
        # Tests des parenth√®ses
        print("üî¢ Tests des parenth√®ses")
        print("-" * 70)
        self.tester_operation("Parenth√®ses simples", "(5 + 3) * 2", 16)
        self.tester_operation("Parenth√®ses imbriqu√©es", "((2 + 3) * (4 + 1))", 25)
        self.tester_operation("Parenth√®ses multiples", "(10 - 2) * (3 + 4)", 56)
        self.tester_operation("Parenth√®ses complexes", 
                            "((5 + 3) * 2) - (4 / 2)", 14.0)
        print()
        
        # Tests des fonctions trigonom√©triques
        print("üìê Tests des fonctions trigonom√©triques (radians)")
        print("-" * 70)
        self.tester_operation("sin(0)", f"math.sin(0)", 0.0)
        self.tester_operation("sin(œÄ/2)", f"math.sin(math.pi/2)", 1.0)
        self.tester_operation("cos(0)", f"math.cos(0)", 1.0)
        self.tester_operation("cos(œÄ)", f"math.cos(math.pi)", -1.0, 1e-9)
        self.tester_operation("tan(0)", f"math.tan(0)", 0.0)
        self.tester_operation("tan(œÄ/4)", f"math.tan(math.pi/4)", 1.0, 1e-9)
        print()
        
        # Tests des fonctions logarithmiques
        print("üìà Tests des fonctions logarithmiques")
        print("-" * 70)
        self.tester_operation("log10(100)", "math.log10(100)", 2.0)
        self.tester_operation("log10(1000)", "math.log10(1000)", 3.0)
        self.tester_operation("log10(1)", "math.log10(1)", 0.0)
        self.tester_operation("ln(e)", f"math.log({math.e})", 1.0)
        self.tester_operation("ln(1)", "math.log(1)", 0.0)
        self.tester_operation("ln(e¬≤)", f"math.log({math.e}**2)", 2.0, 1e-9)
        print()
        
        # Tests des autres fonctions
        print("üî¨ Tests des fonctions avanc√©es")
        print("-" * 70)
        self.tester_operation("Racine carr√©e de 16", "math.sqrt(16)", 4.0)
        self.tester_operation("Racine carr√©e de 2", "math.sqrt(2)", 
                            math.sqrt(2))
        self.tester_operation("Carr√© de 5", "5 ** 2", 25)
        self.tester_operation("Inverse de 4", "1 / 4", 0.25)
        self.tester_operation("Factorielle 5", "math.factorial(5)", 120)
        self.tester_operation("Factorielle 0", "math.factorial(0)", 1)
        self.tester_operation("Constante œÄ", f"math.pi", math.pi)
        self.tester_operation("Constante e", f"math.e", math.e)
        print()
        
        # Tests d'expressions complexes
        print("üßÆ Tests d'expressions complexes")
        print("-" * 70)
        self.tester_operation("Expression mixte 1", 
                            "2 + 3 * 4 - 5 / 2", 11.5)
        self.tester_operation("Expression mixte 2", 
                            "(2 + 3) * (4 - 1) / 3", 5.0)
        self.tester_operation("Expression avec puissance", 
                            "2 ** 3 + 4 ** 2", 24)
        self.tester_operation("Expression compl√®te", 
                            "math.sqrt(16) + 2 ** 3 - 10 / 2", 7.0)
        print()
        
        # Tests de gestion des erreurs
        print("‚ö†Ô∏è Tests de gestion des erreurs")
        print("-" * 70)
        self.tester_erreur("Division par z√©ro", "10 / 0", ZeroDivisionError)
        self.tester_erreur("Logarithme n√©gatif", "math.log(-1)", ValueError)
        self.tester_erreur("Racine n√©gative", "math.sqrt(-4)", ValueError)
        print()
        
        # R√©sum√© des tests
        self.afficher_resume()
    
    def afficher_resume(self):
        """Affiche le r√©sum√© des tests."""
        total = self.tests_reussis + self.tests_echoues
        taux_reussite = (self.tests_reussis / total * 100) if total > 0 else 0
        
        print("=" * 70)
        print(" üìä R√âSUM√â DES TESTS")
        print("=" * 70)
        print(f"‚úÖ Tests r√©ussis : {self.tests_reussis}/{total}")
        print(f"‚ùå Tests √©chou√©s : {self.tests_echoues}/{total}")
        print(f"üìà Taux de r√©ussite : {taux_reussite:.1f}%")
        print()
        
        if self.tests_echoues > 0:
            print("‚ö†Ô∏è Tests en √©chec :")
            print("-" * 70)
            for nom, succes, erreur in self.resultats:
                if not succes:
                    print(f"  ‚Ä¢ {nom}")
                    if erreur:
                        print(f"    ‚Üí {erreur}")
        else:
            print("üéâ Tous les tests ont r√©ussi !")
        
        print("=" * 70)
        print()
        
        return taux_reussite == 100.0


def main():
    """Point d'entr√©e principal des tests."""
    print()
    print("‚ïî" + "‚ïê" * 68 + "‚ïó")
    print("‚ïë" + " " * 15 + "SUITE DE TESTS COMPL√àTE" + " " * 30 + "‚ïë")
    print("‚ïë" + " " * 10 + "Calculatrice Scientifique Tkinter" + " " * 24 + "‚ïë")
    print("‚ïö" + "‚ïê" * 68 + "‚ïù")
    print()
    print(f"üìÖ Date : {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
    print(f"üêç Python : {sys.version.split()[0]}")
    print()
    
    # Ex√©cuter les tests
    testeur = TestCalculatrice()
    tous_reussis = testeur.executer_suite_tests()
    
    # Code de sortie
    sys.exit(0 if tous_reussis else 1)


if __name__ == "__main__":
    main()
